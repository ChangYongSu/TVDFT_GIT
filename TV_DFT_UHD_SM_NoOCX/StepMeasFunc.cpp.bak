#include "stdafx.h"
#include "resource.h"
#include "parser.h"
#include "step.h"
#include "global.h"
#include "realmeas.h"
#include "support.h"
#include "TextOutCtrl.h"
#include "BaseImage.h"
#include "ImageProc.h"
#include "TVCommCtrl.h"
#include "ProgressCtrlX.h"
#include "ManualTestResultInputDlg.h"
#include <malloc.h>
#include "AvSwitchBoxCtrl.h"
//+add kwmoon 080514
#include "SoundCard.h"
//+add kwmoon 080625
#include "I2cAdcCtrl.h"

#include <winsock.h>

#include "Dmm.h"

// Extern
extern CDATsysView*		g_pView;
extern CBaseImage		g_RefImage;
extern CBaseImage		g_GrabImage;
extern CBaseImage		g_MaskImage;
extern CImageProc		g_ImageProc;

extern CAvSwitchBox		AvSwitchBoxCtrl;
extern CProgressCtrlX	ctrlImgProg;
extern BYTE				GrabData[1920][1080][3];
extern CTVCommCtrl		TVCommCtrl;
extern _InputSource		InputDefined[];

//+add kwmoon 080625
extern CI2cAdcCtrl		I2cAdcCtrl;

//+add kwmoon 080514
extern CSoundCard g_SoundCard;

/////////////////////////////
// Image Processing Function
/////////////////////////////

//+add kwmoon 080124
int GetSpecMargin(CString szInputSource)
{
	int nSpecMargin		 = 0;
	int nSpecMarginIndex = -1;

	for(int i = 0; InputDefined[i].pszName != NULL; i++)
	{
		if(szInputSource.Compare(InputDefined[i].pszName) == NULL)
		{
			nSpecMarginIndex = i; break;
		}
	}
	
	if(nSpecMarginIndex != -1)
	{
		nSpecMargin	= CurrentSet->nSrcMargin[nSpecMarginIndex];
	}
	
	return nSpecMargin;
}

double	_Color_Test()
{
	int nResult = TEST_FAIL;

	int nTotalNoErrorPixel	= 0;

	POINT ptResultPosition;
	ptResultPosition.x		= 0;
	ptResultPosition.y		= 0;

	CString sMsg 			= _T("");
	CString szMsg1			= _T("");
	CString szMsg2			= _T("");
	CString szPrevMsg		= _T("");

	float fMaxDifference	= 0.0;

	int   nColorDepth		= 0;
	int   nNoLevel			= 0;

	DWORD dwFuncTickCount     = 0;
	DWORD dwFuncElapsedTime   = 0;
	CString szFuncElapsedTime = _T("");

	if(CurrentSet->bSaveProcessingTimeData)
	{
		sMsg.Format("  B-ColorTest");
		AddTimeData(sMsg);
		dwFuncTickCount = GetTickCount();
	}

	//090324
	pCurStep->m_bRunVideoTest = TRUE;
	//+add kwmoon 080819
	g_ImageProc.m_ptPositionShift.x = 0;
	g_ImageProc.m_ptPositionShift.y = 0;

	g_ImageProc.SetColorLimit((float)pCurStep->m_fLowLimit,(float)pCurStep->m_fHighLimit);
	g_ImageProc.SetAvgMaskSize(0,0,0); 

	if(g_GrabImage.m_bImageLoaded && g_RefImage.m_bImageLoaded)
	{
		nResult = g_ImageProc.RGBTest(NORMAL_IMAGE_TEST,g_GrabImage,g_RefImage,g_MaskImage,
									  ptResultPosition, fMaxDifference,nTotalNoErrorPixel,g_MaskImage.m_bImageLoaded,ctrlImgProg);
	

		if(nResult == TEST_FAIL)
		{
			CRect nImageRect;
			CWnd* pImageWnd;

			pImageWnd = g_pView->GetDlgItem(IDC_VIDEOVIEW);
			pImageWnd->GetWindowRect(&nImageRect);
			
			if(!Grab_Image_2in1(_T(""),0))
			{
				nResult =  TEST_FAIL;
			}
			else
			{
				g_pView->InvalidateRect(nImageRect, FALSE);
				g_pView->UpdateWindow(); _Wait(10);
			
				nResult = g_ImageProc.RGBTest(NORMAL_IMAGE_TEST,g_GrabImage,g_RefImage,g_MaskImage,
									  ptResultPosition, fMaxDifference,nTotalNoErrorPixel,g_MaskImage.m_bImageLoaded,ctrlImgProg);
			}
		}

		pCurStep->m_nTestType = RGB_TEST;
		pCurStep->m_nTotalNoErrorPixel = nTotalNoErrorPixel;
	
		nColorDepth	 = g_RefImage.m_InfoHeader.biBitCount;

		//+change kwmoon 080722
//		nNoLevel	 = (int)pow(2,(nColorDepth/3));		//+add kwmoon 080716
		nNoLevel	 = (int)pow(2,(nColorDepth/3))-1;		//+add kwmoon 080716
		
		//+add kwmoon 080716
		switch(nResult)
		{
			case TEST_PASS  : pCurStep->m_bResult = TRUE;  break;
			case TEST_FAIL  : pCurStep->m_bResult = FALSE; break;
			case TEST_ABORT : 
			{
				pCurStep->m_bResult = FALSE; break;
				pCurStep->m_nTotalNoErrorPixel = -1;

				AfxMessageBox("Failed to run color test");
				return MAX_COLOR_LEVEL;
			}
		}

		g_GrabImage.m_bSaveProcessedImage = TRUE; 

		
		if((CurrentSet->bSaveGrabImg)
		|| (!CurrentSet->bSaveGrabImg && (nResult == TEST_FAIL)))
		{
			//=================
			// Save Grab Image 
			//=================
			if(pCurStep->m_strGrabPath == _T(""))
			{
				pCurStep->m_strGrabPath = g_GrabImage.m_szFilePath;
			}
			g_GrabImage.SaveImage(pCurStep->m_strGrabPath, SNAP_IMAGE,ctrlImgProg);

			//======================
			// Save Processed Image 
			//======================
			if(g_GrabImage.m_bProcessedImageLoaded && g_GrabImage.m_bSaveProcessedImage)
			{
				if(pCurStep->m_strProcPath == _T(""))
				{
					pCurStep->m_strProcPath = g_GrabImage.m_szFilePath.Left(g_GrabImage.m_szFilePath.ReverseFind('.')) + ".rst";
				}
				g_GrabImage.SaveImage(pCurStep->m_strProcPath, INTERNAL_PROC_IMAGE,ctrlImgProg);
			}
		}

		//================
		// Save Test Data 
		//================
		if(CurrentSet->bSaveReviewData || CurrentSet->bSaveDetailResultData || g_pView->m_bAdjSpecMode)
		{
			for(int i=0; i<3; i++)
			{
				for(int j=0; j<NO_DIFFERENT_POINT_BLOCK; j++)
				{
					pCurStep->m_aNoDifferentPoint[i][j] = g_ImageProc.m_aNoDifferentPoint[i][j];
				}
			}
			pCurStep->m_nSecondDifferentPointFreePercent = g_ImageProc.m_nSecondDifferentPointFreePercent;
		}

		for(int i=0; i<5; i++)
		{
			pCurStep->m_nNoBandErrorPixel[i]				= g_ImageProc.m_nNoBandErrorPixel[i];
			pCurStep->m_nNoAllowedBandErrorPixel[i]			= g_ImageProc.m_nNoAllowedBandErrorPixel[i];
			pCurStep->m_fBandErrorPixelPercentage[i]		= g_ImageProc.m_fBandErrorPixelPercentage[i];
			pCurStep->m_fAllowedBandErrorPixelPercentage[i]	= g_ImageProc.m_fAllowedBandErrorPixelPercentage[i];
		}
		pCurStep->m_fGoodPixelPercentage = g_ImageProc.m_fGoodPixelPercentage;

		pCurStep->m_nNoRoiPixel		= g_ImageProc.m_nNoRoiPixel;
		pCurStep->m_nNoTargetPixel	= g_ImageProc.m_nNoTargetPixel;
		pCurStep->m_nNoGoodPixel	= g_ImageProc.m_nNoGoodPixel;


		//================
		// Show Test Data
		//================
		szMsg1.Format("Good:%.1f | Error:%.2f/%.2f/%.3f/%.3f/%.3f",
		pCurStep->m_fGoodPixelPercentage,pCurStep->m_fBandErrorPixelPercentage[0],
		pCurStep->m_fBandErrorPixelPercentage[1],pCurStep->m_fBandErrorPixelPercentage[2],
		pCurStep->m_fBandErrorPixelPercentage[3],pCurStep->m_fBandErrorPixelPercentage[4]);
		
		if((nResult == TEST_PASS) && g_pView->m_bAdjSpecMode)
		{
			if(g_pView->m_bAdjSpecMode && pCurStep->m_nSecondDifferentPointFreePercent != -1)
			{
//090519
//				nSpecMargin  = GetSpecMargin(pCurStep->m_strCurSrc);
//				fNewHighSpec = (float)pCurStep->m_nSecondDifferentPointFreePercent+nSpecMargin;
//				fNewLowSpec  = (float)(-1)*(pCurStep->m_nSecondDifferentPointFreePercent+nSpecMargin);

//				szMsg2.Format("Spec : L(%.1f>%.1f) H(%.1f>%.1f)",
//							   pCurStep->GetLowLimit(),fNewLowSpec,
//							   pCurStep->GetHighLimit(),fNewHighSpec);

				szMsg2.Format("Spec : L(%.1f) H(%.1f)",pCurStep->GetLowLimit(), pCurStep->GetHighLimit());

//Skip PSH 080816
//				pCurStep->SetHighLimit(fNewHighSpec);
//				pCurStep->SetLowLimit(fNewLowSpec);
				pCurStep->m_nAudioMargin = CurrentSet->nFreqMargin;

				szMsg1 = szMsg2 + " , " + szMsg1;
			}
		}
		
		if(CurrentSet->nDisplayType == DETAILEDGRID)
		{
			g_pView->GetResultFromDetailedGrid(pCurStep->m_nStep, szPrevMsg); 
			
			if(szPrevMsg != _T(""))
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szPrevMsg + " , " + szMsg1);
				pCurStep->m_strMsg = szPrevMsg + " , " + szMsg1;
			}
			else
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szMsg1);
				pCurStep->m_strMsg = szMsg1;
			}		
		}

		if(CurrentSet->bSaveProcessingTimeData)
		{
			DWORD dwStepElapsedTime = GetTickCount()-g_pView->m_dwStepElapsedTime;
	
			dwFuncElapsedTime = GetTickCount()-dwFuncTickCount;
			szFuncElapsedTime.Format("  E-ColorTest [%dms] (%dms)",dwFuncElapsedTime,dwStepElapsedTime);
			AddTimeData(szFuncElapsedTime);
		}
	
		if(nResult == TEST_PASS)
		{
			if((fMaxDifference < 0) && (fMaxDifference < pCurStep->m_fLowLimit))
			{
				return pCurStep->m_fLowLimit;
			}
			
			if((fMaxDifference >= 0) && (fMaxDifference > pCurStep->m_fHighLimit))
			{
				return pCurStep->m_fHighLimit;
			}
		}
		else
		{
			if(fMaxDifference >= 0)
			{
				if(fMaxDifference < 100) fMaxDifference += 1;
			}
			else
			{
				if(fMaxDifference > -100) fMaxDifference -= 1;
			}
		}
	
		return fMaxDifference; 	
	}
	else
	{
		return 100;//MAX_COLOR_LEVEL; 	
	}
}


// Image Processing Function
double	_Signal_Line_Test()
{
	int nResult = TEST_FAIL;


	CString szMsg		= _T("");
	CString szPrevMsg	= _T("");
	CString szColor		= _T("");

	//090324
	pCurStep->m_bRunVideoTest = TRUE;
	// Initialization
	//+change kwmoon 070929
	g_ImageProc.SetColorLimit((float)pCurStep->m_fLowLimit,(float)pCurStep->m_fHighLimit);
	g_ImageProc.SetAvgMaskSize(0,0,0); 

	if(g_GrabImage.m_bImageLoaded && g_RefImage.m_bImageLoaded)
	{
		g_ImageProc.m_LineBitTestData.InitBitTestData();
		g_ImageProc.m_LineBitTestData.m_pGrabImage	= &g_GrabImage;
		g_ImageProc.m_LineBitTestData.m_pRefImage	= &g_RefImage;
		g_ImageProc.m_LineBitTestData.m_pMaskImage	= &g_MaskImage;

		nResult = g_ImageProc.SignalLineTest(NORMAL_IMAGE_TEST,g_MaskImage.m_bImageLoaded,ctrlImgProg);
	
		// Initialization
		g_ImageProc.SetAvgMaskSize(0,0,0); 
		//+del kwmoon 080618
	//	g_ImageProc.SetRoi(ptZeroPosition,ptZeroPosition);
		
		pCurStep->m_nTestType = SIGNAL_LINE_TEST;

//		pCurStep->m_nTotalNoErrorPixel = nTotalNoErrorPixel;

		if(nResult == TEST_ABORT) return 0.0;

		pCurStep->m_nTotalNoMaskedPixel		= g_ImageProc.m_LineBitTestData.m_nTotalNoMaskedPixel;
		pCurStep->m_nTotalNoUnmaskedPixel	= g_ImageProc.m_LineBitTestData.m_nTotalNoUnmaskedPixel;
		pCurStep->m_nBitCount				= g_ImageProc.m_LineBitTestData.m_nBitCount;

		for(int i=0; i<3; i++)
		{
			for(int j=0; j<MAX_NO_COLOR_BITS; j++)
			{
				pCurStep->m_aRefNoHighBit[i][j]		= g_ImageProc.m_LineBitTestData.m_aRefNoHighBit[i][j];
				pCurStep->m_aGrabNoHighBit[i][j]	= g_ImageProc.m_LineBitTestData.m_aGrabNoHighBit[i][j];
			}
		}

		if(nResult == TEST_PASS)
		{
			return 1.0;
		}
		else
		{
			switch(g_ImageProc.m_LineBitTestData.m_nErrorColor)
			{
				case 0 : szColor = "B"; break;
				case 1 : szColor = "G"; break;
				case 2 : szColor = "R"; break;
			}
			
			szMsg.Format("Faulty Bit Position : %s(%d)",szColor,
						 g_ImageProc.m_LineBitTestData.m_nErrorBitPosition);

			// Show Message
			if(CurrentSet->nDisplayType == DETAILEDGRID)
			{
				g_pView->GetResultFromDetailedGrid(pCurStep->m_nStep, szPrevMsg); 
				
				if(szPrevMsg != _T(""))
				{
					g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szPrevMsg + " , " + szMsg);
				}
				else
				{
					g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szMsg);
				}		
			}		
			return 0.0;
		}
	}
	else
	{
		return 0.0;	
	}
}

// Image Processing Function
double	_Noise_Test()
{
	int nResult = TEST_FAIL;

	int nMaxDifference		= 0;
	int nPlusMaxDifference	= 0;
	int nMinusMaxDifference = 0;
	int nTotalNoErrorPixel	= 0;

	POINT ptResultPosition;
	ptResultPosition.x = 0;
	ptResultPosition.y = 0;

	POINT ptPlusResultPosition;
	ptPlusResultPosition.x = 0;
	ptPlusResultPosition.y = 0;

	POINT ptMinusResultPosition;
	ptMinusResultPosition.x = 0;
	ptMinusResultPosition.y = 0;

//	POINT ptZeroPosition;
//	ptZeroPosition.x = 0;
//	ptZeroPosition.y = 0;

	CString szMsg1 = _T("");
	CString szMsg2 = _T("");
	CString szPrevMsg = _T("");

//	float fNewHighSpec = 0.0;
//	float fNewLowSpec  = 0.0;
	int   nColorDepth  = 0;
	int   nNoLevel	   = 0;

	//+add kwmoon 080124
//	int nSpecMargin	   = 0;

	CString sMsg		  = _T("");
	DWORD dwFuncTickCount     = 0;
	DWORD dwFuncElapsedTime   = 0;
	CString szFuncElapsedTime = _T("");

	if(CurrentSet->bSaveProcessingTimeData)
	{
		sMsg.Format("  B-NoiseTest");
		AddTimeData(sMsg);
		dwFuncTickCount = GetTickCount();
	}

	//090324
	pCurStep->m_bRunVideoTest = TRUE;
	//+add kwmoon 080819
	g_ImageProc.m_ptPositionShift.x = 0;
	g_ImageProc.m_ptPositionShift.y = 0;

	// Initialization
	g_ImageProc.SetColorLimit((float)pCurStep->m_fLowLimit,(float)pCurStep->m_fHighLimit);
	g_ImageProc.SetAvgMaskSize(0,0,0); 

	if(g_GrabImage.m_bImageLoaded && g_RefImage.m_bImageLoaded)
	{
		nResult = g_ImageProc.NoiseTest(NORMAL_IMAGE_TEST,g_GrabImage,g_RefImage,g_MaskImage,
									  ptPlusResultPosition,ptMinusResultPosition, 
									  nPlusMaxDifference,nMinusMaxDifference,nTotalNoErrorPixel,g_MaskImage.m_bImageLoaded,ctrlImgProg);
	
		// Initialization
		g_ImageProc.SetAvgMaskSize(0,0,0); 
		//+del kwmoon 080618
	//	g_ImageProc.SetRoi(ptZeroPosition,ptZeroPosition);
		
		pCurStep->m_nTestType = RGB_TEST;
		pCurStep->m_nTotalNoErrorPixel = nTotalNoErrorPixel;

		//+add kwmoon 080716
		for(int i=0; i<5; i++)
		{
			pCurStep->m_nNoBandErrorPixel[i]				= g_ImageProc.m_nNoBandErrorPixel[i];
			pCurStep->m_nNoAllowedBandErrorPixel[i]			= g_ImageProc.m_nNoAllowedBandErrorPixel[i];
			pCurStep->m_fBandErrorPixelPercentage[i]		= g_ImageProc.m_fBandErrorPixelPercentage[i];
			pCurStep->m_fAllowedBandErrorPixelPercentage[i]	= g_ImageProc.m_fAllowedBandErrorPixelPercentage[i];
		}
		pCurStep->m_fGoodPixelPercentage = g_ImageProc.m_fGoodPixelPercentage;

		pCurStep->m_nNoRoiPixel		= g_ImageProc.m_nNoRoiPixel;
		pCurStep->m_nNoTargetPixel	= g_ImageProc.m_nNoTargetPixel;
		pCurStep->m_nNoGoodPixel	= g_ImageProc.m_nNoGoodPixel;


		if(nResult == TEST_ABORT)
		{
			//+add kwmoon 080201
			AfxMessageBox("Failed to run noise test");

			return MAX_COLOR_LEVEL;
		}

		nColorDepth	 = g_RefImage.m_InfoHeader.biBitCount;

		//+change kwmoon 080722
//		nNoLevel	 = (int)pow(2,(nColorDepth/3));		//+add kwmoon 080716
		nNoLevel	 = (int)pow(2,(nColorDepth/3))-1;		//+add kwmoon 080716
		
		//+change kwmoon 080715
		g_GrabImage.m_bSaveProcessedImage = TRUE; // CurrentSet->bSaveProcImg;
		
		//+add kwmoon 080715 : if statement 
		if((CurrentSet->bSaveGrabImg)
		|| (!CurrentSet->bSaveGrabImg && (nResult == TEST_FAIL)))
		{
			//=================
			// Save Grab Image 
			//=================
			if(pCurStep->m_strGrabPath == _T(""))
			{
				pCurStep->m_strGrabPath = g_GrabImage.m_szFilePath;
			}
			g_GrabImage.SaveImage(pCurStep->m_strGrabPath, SNAP_IMAGE,ctrlImgProg);

			//======================
			// Save Processed Image 
			//======================
			if(g_GrabImage.m_bProcessedImageLoaded && g_GrabImage.m_bSaveProcessedImage)
			{
				if(pCurStep->m_strProcPath == _T(""))
				{
					pCurStep->m_strProcPath = g_GrabImage.m_szFilePath.Left(g_GrabImage.m_szFilePath.ReverseFind('.')) + ".rst";
				}
				g_GrabImage.SaveImage(pCurStep->m_strProcPath, INTERNAL_PROC_IMAGE,ctrlImgProg);
			}
		}

		//+add kwmoon 070807
		for(i=0; i<3; i++)
		{
			for(int j=0; j<NO_DIFFERENT_POINT_BLOCK; j++)
			{
				pCurStep->m_aNoDifferentPoint[i][j] = g_ImageProc.m_aNoDifferentPoint[i][j];
			}
		}
		pCurStep->m_nSecondDifferentPointFreePercent = g_ImageProc.m_nSecondDifferentPointFreePercent;

		if(nPlusMaxDifference >= abs(nMinusMaxDifference))
		{
			nMaxDifference		= nPlusMaxDifference;
			ptResultPosition.x  = ptPlusResultPosition.x;
			ptResultPosition.y  = ptPlusResultPosition.y;
		}
		else
		{
			nMaxDifference		= nMinusMaxDifference;
			ptResultPosition.x  = ptMinusResultPosition.x;
			ptResultPosition.y  = ptMinusResultPosition.y;
		}

		//+del kwmoon 080716
		szMsg1.Format("Good:%.1f | Error : %.2f/%.2f/%.3f/%.3f/%.3f",
		pCurStep->m_fGoodPixelPercentage,pCurStep->m_fBandErrorPixelPercentage[0],
		pCurStep->m_fBandErrorPixelPercentage[1],pCurStep->m_fBandErrorPixelPercentage[2],
		pCurStep->m_fBandErrorPixelPercentage[3],pCurStep->m_fBandErrorPixelPercentage[4]);
	
		if((nResult == TEST_PASS) && g_pView->m_bAdjSpecMode)
		{
			if(g_pView->m_bAdjSpecMode && pCurStep->m_nSecondDifferentPointFreePercent != -1)
			{
//090519
//				nSpecMargin  = GetSpecMargin(pCurStep->m_strCurSrc);
//				fNewHighSpec = (float)pCurStep->m_nSecondDifferentPointFreePercent+nSpecMargin;
//				fNewLowSpec  = (float)(-1)*(pCurStep->m_nSecondDifferentPointFreePercent+nSpecMargin);

//				szMsg2.Format("Spec : L(%.1f>%.1f) H(%.1f>%.1f)",
//							   pCurStep->GetLowLimit(),fNewLowSpec,
//							   pCurStep->GetHighLimit(),fNewHighSpec);

				szMsg2.Format("Spec : L(%.1f) H(%.1f)",pCurStep->GetLowLimit(), pCurStep->GetHighLimit());

//Skip PSH 080816
//				pCurStep->SetHighLimit(fNewHighSpec);
//				pCurStep->SetLowLimit(fNewLowSpec);

				//+add kwmoon 080123
				pCurStep->m_nAudioMargin = CurrentSet->nFreqMargin;

				szMsg1 = szMsg2 + " , " + szMsg1;
			}
		}

		if(CurrentSet->nDisplayType == DETAILEDGRID)
		{
			g_pView->GetResultFromDetailedGrid(pCurStep->m_nStep, szPrevMsg); 
			
			if(szPrevMsg != _T(""))
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szPrevMsg + " , " + szMsg1);
				pCurStep->m_strMsg = szPrevMsg + " , " + szMsg1;
			}
			else
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szMsg1);
				pCurStep->m_strMsg = szMsg1;
			}		
		}
		
		if(CurrentSet->bSaveProcessingTimeData)
		{
			DWORD dwStepElapsedTime = GetTickCount()-g_pView->m_dwStepElapsedTime;

			dwFuncElapsedTime = GetTickCount()-dwFuncTickCount;
			szFuncElapsedTime.Format("  E-NoiseTest [%dms] (%dms)",dwFuncElapsedTime,dwStepElapsedTime);
			AddTimeData(szFuncElapsedTime);
		}

		float fReturnPercentageValue = g_ImageProc.Level2Percentage(nMaxDifference,nNoLevel);

		if(nResult == TEST_PASS)
		{
			if((fReturnPercentageValue < 0) && (fReturnPercentageValue < pCurStep->m_fLowLimit))
			{
				return pCurStep->m_fLowLimit;
			}
			
			if((fReturnPercentageValue >= 0) && (fReturnPercentageValue > pCurStep->m_fHighLimit))
			{
				return pCurStep->m_fHighLimit;
			}
		}
		else
		{
			if(fReturnPercentageValue >= 0)
			{
				if(fReturnPercentageValue < 100) fReturnPercentageValue += 1;
			}
			else
			{
				if(fReturnPercentageValue > -100) fReturnPercentageValue -= 1;
			}
		}
	
		return fReturnPercentageValue; 	
	}
	else
	{
		return MAX_COLOR_LEVEL; 	
	}
}

// Image Processing Function
double	_Bright_Test()
{
	int nResult = TEST_FAIL;

	int nMaxDifference = 0;

	POINT ptResultPosition;
	ptResultPosition.x = 0;
	ptResultPosition.y = 0;

	CString szMsg;
	CString szPrevMsg;

	int nBrightMarginLevel = (int)pCurStep->m_fHighLimit;
	//090324
	pCurStep->m_bRunVideoTest = TRUE;

	if(g_GrabImage.m_bImageLoaded && g_RefImage.m_bImageLoaded)
	{
		g_ImageProc.SetBrightMargin(nBrightMarginLevel);

		nResult = g_ImageProc.BrightnessTest(g_GrabImage, g_RefImage,g_MaskImage,ptResultPosition,nMaxDifference,ctrlImgProg);

		// Initialization
		g_ImageProc.SetAvgMaskSize(0,0,0); 

		pCurStep->m_nTestType = BRIGHT_TEST;

		if(nResult == TEST_ABORT) return MAX_COLOR_LEVEL;
		
		//+change kwmoon 080715
		g_GrabImage.m_bSaveProcessedImage = TRUE; //CurrentSet->bSaveProcImg;

		//+add kwmoon 080715 : if statement 
		if((CurrentSet->bSaveGrabImg)
		|| (!CurrentSet->bSaveGrabImg && (nResult == TEST_FAIL)))
		{
			//=================
			// Save Grab Image 
			//=================
			if(pCurStep->m_strGrabPath == _T(""))
			{
				pCurStep->m_strGrabPath = g_GrabImage.m_szFilePath;
			}
			g_GrabImage.SaveImage(pCurStep->m_strGrabPath, SNAP_IMAGE,ctrlImgProg);

			//======================
			// Save Processed Image 
			//======================
			if(g_GrabImage.m_bProcessedImageLoaded && g_GrabImage.m_bSaveProcessedImage)
			{
				if(pCurStep->m_strProcPath == _T(""))
				{
					pCurStep->m_strProcPath = g_GrabImage.m_szFilePath.Left(g_GrabImage.m_szFilePath.ReverseFind('.')) + ".rst";
				}
				g_GrabImage.SaveImage(pCurStep->m_strProcPath, INTERNAL_PROC_IMAGE,ctrlImgProg);
			}
		}

		szMsg.Format("Diff : %d(%d,%d)",nMaxDifference,ptResultPosition.x,ptResultPosition.y);

		if(CurrentSet->nDisplayType == DETAILEDGRID)
		{
			g_pView->GetResultFromDetailedGrid(pCurStep->m_nStep, szPrevMsg); 
			
			if(szPrevMsg != _T(""))
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szPrevMsg + " , " +szMsg);
				//+ 2007.7.23 Add BY USY
				pCurStep->m_strMsg = szPrevMsg + " , " + szMsg;
				//-
			}
			else
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szMsg);
				//+ 2007.7.23 Add BY USY
				pCurStep->m_strMsg = szMsg;
				//-
			}		
		}
		return nMaxDifference;
	}
	else
	{
		return MAX_COLOR_LEVEL; 	
	}	
}

// Image Processing Function
double	_Position_Test()
{
	int nResult = TEST_FAIL;

	POINT ptResultPosition;
	ptResultPosition.x = 0;
	ptResultPosition.y = 0;

	POINT ptPositionShift;
	ptPositionShift.x = 0;
	ptPositionShift.y = 0;

//	POINT ptZeroPosition;
//	ptZeroPosition.x = 0;
//	ptZeroPosition.y = 0;

	float fMatchRate = 0.0f;

	CString szMsg;
	CString szPrevMsg;
	//090324
	pCurStep->m_bRunVideoTest = TRUE;

	if(g_GrabImage.m_bImageLoaded && g_RefImage.m_bImageLoaded)
	{
		// Initialize position shift
		// In case of position test, set position shift 0
		g_ImageProc.SetPositionShift(ptPositionShift);

		nResult = g_ImageProc.PatternMatching(POSITION_TEST,g_GrabImage,g_RefImage,ptResultPosition,fMatchRate,ctrlImgProg);

		pCurStep->m_nTestType = POSITION_TEST;

		if(nResult == TEST_ABORT) return 0.0;

		szMsg.Format("Match : %.1f%% (%d,%d)",fMatchRate,ptResultPosition.x,ptResultPosition.y);

		if(CurrentSet->nDisplayType == DETAILEDGRID)
		{
			g_pView->GetResultFromDetailedGrid(pCurStep->m_nStep, szPrevMsg); 
			
			if(szPrevMsg != _T(""))
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szPrevMsg + " , " +szMsg);
				pCurStep->m_strMsg = szPrevMsg + " , " + szMsg;
			}
			else
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szMsg);
				pCurStep->m_strMsg = szMsg;
			}		
		}

		if(nResult == TEST_PASS)
		{
			if((g_ImageProc.m_nRoiHeight > 0) && (g_ImageProc.m_nRoiWidth > 0)) // In case of applying ROI
			{
				g_ImageProc.m_ptPositionShift.x = ptResultPosition.x - g_ImageProc.m_ptRoiPosition.x;
				g_ImageProc.m_ptPositionShift.y = ptResultPosition.y - g_ImageProc.m_ptRoiPosition.y;
			}
			else
			{
				g_ImageProc.m_ptPositionShift = ptResultPosition;
			}
		}
		else
		{
				g_ImageProc.m_ptPositionShift.x = 0;
				g_ImageProc.m_ptPositionShift.y = 0;
		}
	}

	// Initialize Roi variable
	//+del kwmoon 080618
//	g_ImageProc.SetRoi(ptZeroPosition,ptZeroPosition); 

	if(nResult == TEST_PASS) return 1.0;
	else return 0.0;
}

//===========================
// Image Processing Function
//===========================

double	_Osd_Test()
{
	int nResult				= TEST_FAIL;

	int nTotalNoErrorPixel	= 0;

	POINT ptResultPosition;
	ptResultPosition.x		= 0;
	ptResultPosition.y		= 0;

	CString sMsg			= _T("");
	CString szMsg			= _T("");
	CString szMsg1			= _T("");
	CString szMsg2			= _T("");
	CString szPrevMsg		= _T("");

	float fMatchRate		= 0.0;
	float fMaxDifference	= 0.0;

	BOOL  bOsdTestAfterPatternMatch = FALSE;

	DWORD dwFuncTickCount     = 0;
	DWORD dwFuncElapsedTime   = 0;
	CString szFuncElapsedTime = _T("");

	//090324
	pCurStep->m_bRunVideoTest = TRUE;
	if(CurrentSet->bSaveProcessingTimeData)
	{
		sMsg.Format("  B-OsdTest");
		AddTimeData(sMsg);
		dwFuncTickCount = GetTickCount();
	}

	//+add kwmoon 080819
	g_ImageProc.m_ptPositionShift.x = 0;
	g_ImageProc.m_ptPositionShift.y = 0;

	if(g_GrabImage.m_bImageLoaded && g_RefImage.m_bImageLoaded)
	{
	

START_OSD_TEST :

		g_ImageProc.SetColorLimit((float)pCurStep->m_fLowLimit,(float)pCurStep->m_fHighLimit);
		g_ImageProc.SetAvgMaskSize(0,0,0); 
		
		nResult = g_ImageProc.RGBTest(OSD_IMAGE_TEST,g_GrabImage,g_RefImage,g_MaskImage,
								  ptResultPosition,fMaxDifference,nTotalNoErrorPixel,g_MaskImage.m_bImageLoaded,ctrlImgProg);

		// Initialization
		g_ImageProc.SetAvgMaskSize(0,0,0); 
	
		pCurStep->m_nTotalNoErrorPixel = nTotalNoErrorPixel;
		
		if(nResult == TEST_ABORT)
		{
			pCurStep->m_nTotalNoErrorPixel = -1;
			AfxMessageBox("Failed to run osd test");
			return 100;
		}
		
		g_GrabImage.m_bSaveProcessedImage = TRUE; 

		if((CurrentSet->bSaveGrabImg)
		|| (!CurrentSet->bSaveGrabImg && (nResult == TEST_FAIL)))
		{
			//=================
			// Save Grab Image 
			//=================
			if(pCurStep->m_strGrabPath == _T(""))
			{
				pCurStep->m_strGrabPath = g_GrabImage.m_szFilePath;
			}
			g_GrabImage.SaveImage(pCurStep->m_strGrabPath, SNAP_IMAGE,ctrlImgProg);

			//======================
			// Save Processed Image 
			//======================
			if(g_GrabImage.m_bProcessedImageLoaded && g_GrabImage.m_bSaveProcessedImage)
			{
				if(pCurStep->m_strProcPath == _T(""))
				{
					pCurStep->m_strProcPath = g_GrabImage.m_szFilePath.Left(g_GrabImage.m_szFilePath.ReverseFind('.')) + ".rst";
				}
				g_GrabImage.SaveImage(pCurStep->m_strProcPath, INTERNAL_PROC_IMAGE,ctrlImgProg);
			}
		}

		//================
		// Save Test Data 
		//================
		if(CurrentSet->bSaveReviewData || CurrentSet->bSaveDetailResultData || g_pView->m_bAdjSpecMode)
		{
			for(int i=0; i<3; i++)
			{
				for(int j=0; j<NO_DIFFERENT_POINT_BLOCK; j++)
				{
					pCurStep->m_aNoDifferentPoint[i][j] = g_ImageProc.m_aNoDifferentPoint[i][j];
				}
			}
			pCurStep->m_nSecondDifferentPointFreePercent = g_ImageProc.m_nSecondDifferentPointFreePercent;
		}

		for(int i=0; i<5; i++)
		{
			pCurStep->m_nNoBandErrorPixel[i]				= g_ImageProc.m_nNoBandErrorPixel[i];
			pCurStep->m_nNoAllowedBandErrorPixel[i]			= g_ImageProc.m_nNoAllowedBandErrorPixel[i];
			pCurStep->m_fBandErrorPixelPercentage[i]		= g_ImageProc.m_fBandErrorPixelPercentage[i];
			pCurStep->m_fAllowedBandErrorPixelPercentage[i]	= g_ImageProc.m_fAllowedBandErrorPixelPercentage[i];
		}
		pCurStep->m_fGoodPixelPercentage = g_ImageProc.m_fGoodPixelPercentage;

		pCurStep->m_nNoRoiPixel		= g_ImageProc.m_nNoRoiPixel;
		pCurStep->m_nNoTargetPixel	= g_ImageProc.m_nNoTargetPixel;
		pCurStep->m_nNoGoodPixel	= g_ImageProc.m_nNoGoodPixel;

		//================
		// Show Test Data
		//================
		szMsg1.Format("Good:%.1f | Error : %.2f/%.2f/%.3f/%.3f/%.3f",
		pCurStep->m_fGoodPixelPercentage,pCurStep->m_fBandErrorPixelPercentage[0],
		pCurStep->m_fBandErrorPixelPercentage[1],pCurStep->m_fBandErrorPixelPercentage[2],
		pCurStep->m_fBandErrorPixelPercentage[3],pCurStep->m_fBandErrorPixelPercentage[4]);

		//=======================
		// Display Adjusted Spec 
		//=======================
		if((nResult == TEST_PASS) && g_pView->m_bAdjSpecMode)
		{
			if(g_pView->m_bAdjSpecMode && pCurStep->m_nSecondDifferentPointFreePercent != -1)
			{

				szMsg2.Format("Spec : L(%.1f) H(%.1f)",pCurStep->GetLowLimit(), pCurStep->GetHighLimit());

//Skip PSH 080816
//				pCurStep->SetHighLimit(fNewHighSpec);
//				pCurStep->SetLowLimit(fNewLowSpec);
				pCurStep->m_nAudioMargin = CurrentSet->nFreqMargin;

				szMsg1 = szMsg2 + " , " + szMsg1;
			}
		}
		
		if(CurrentSet->nDisplayType == DETAILEDGRID)
		{
			g_pView->GetResultFromDetailedGrid(pCurStep->m_nStep, szPrevMsg); 
			
			if(szPrevMsg != _T(""))
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szPrevMsg + " , " + szMsg1);
				pCurStep->m_strMsg = szPrevMsg + " , " + szMsg1;
			}
			else
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szMsg1);
				pCurStep->m_strMsg = szMsg1;
			}		
		}

		if(CurrentSet->bSaveProcessingTimeData)
		{
			DWORD dwStepElapsedTime = GetTickCount()-g_pView->m_dwStepElapsedTime;

			DWORD dwFuncElapsedTime = GetTickCount()-dwFuncTickCount;
			szFuncElapsedTime.Format("  E-OsdTest [%dms] (%dms)",dwFuncElapsedTime,dwStepElapsedTime);
			AddTimeData(szFuncElapsedTime);
		}

		//================
		// NORMAL_PROCESS 
		//================
		if(pCurStep->GetTestParm() == NORMAL_PROCESS)
		{
			if(nResult == TEST_PASS)
			{
				if((fMaxDifference < 0) && (fMaxDifference < pCurStep->m_fLowLimit))
				{
					return pCurStep->m_fLowLimit;
				}

				if((fMaxDifference >= 0) && (fMaxDifference > pCurStep->m_fHighLimit))
				{
					return pCurStep->m_fHighLimit;
				}
				return fMaxDifference;
			}
			else
			{
				if(bOsdTestAfterPatternMatch)
				{
					return 100;
				}

				//==================
				// Pattern Matching 
				//==================

				nResult = g_ImageProc.PatternMatching(OSD_TEST,g_GrabImage,g_RefImage,ptResultPosition,fMatchRate,ctrlImgProg);
			
				if(nResult == TEST_ABORT)
				{
					return 100;
				}
				
				szMsg.Format("Match : %.1f%% (%d,%d)",fMatchRate,ptResultPosition.x,ptResultPosition.y);

				if(nResult == TEST_PASS)
				{
					if((g_ImageProc.m_nRoiHeight > 0) && (g_ImageProc.m_nRoiWidth > 0)) 
					{
						g_ImageProc.m_ptPositionShift.x = ptResultPosition.x - g_ImageProc.m_ptRoiPosition.x;
						g_ImageProc.m_ptPositionShift.y = ptResultPosition.y - g_ImageProc.m_ptRoiPosition.y;
					}
					else
					{
						g_ImageProc.m_ptPositionShift = ptResultPosition;
					}
				}
				else
				{
						g_ImageProc.m_ptPositionShift.x = 0;
						g_ImageProc.m_ptPositionShift.y = 0;
				}
			
				if(CurrentSet->nDisplayType == DETAILEDGRID)
				{
					g_pView->GetResultFromDetailedGrid(pCurStep->m_nStep, szPrevMsg); 
					
					if(szPrevMsg != _T(""))
					{
						g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szPrevMsg + " , " +szMsg);
						pCurStep->m_strMsg = szPrevMsg + " , " + szMsg;
					}
					else
					{
						g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szMsg);
						pCurStep->m_strMsg = szMsg;
					}		
				}

				if(nResult == TEST_PASS)
				{
					bOsdTestAfterPatternMatch = TRUE; goto START_OSD_TEST;
				}
				else
				{
					return 100;
				}
			}
		}
		//=================
		// REVERSE_PROCESS 
		//=================
		else
		{
			if(nResult == TEST_FAIL)
			{
				if(CurrentSet->bSaveProcessingTimeData)
				{
					DWORD dwStepElapsedTime = GetTickCount()-g_pView->m_dwStepElapsedTime;
			
					DWORD dwFuncElapsedTime = GetTickCount()-dwFuncTickCount;
					szFuncElapsedTime.Format("  E-OsdTest [%dms] (%dms)",dwFuncElapsedTime,dwStepElapsedTime);
					AddTimeData(szFuncElapsedTime);
				}
				
				//+add kwmoon 080131
				pCurStep->SetTestParm(NORMAL_PROCESS);

				return fMaxDifference;
			}
			else
			{
				return 100;
			}

		}
	}
	else
	{
		AfxMessageBox("Failed to load grab or reference image");
		return 100;
	}
}

//+del kwmoon 080131

// Image Processing Function
// The result of position test affects a size test on position shift.
double	_Size_Test()
{
	int nResult = TEST_FAIL;

	POINT ptResultPosition;
	ptResultPosition.x = 0;
	ptResultPosition.y = 0;

//	POINT ptZeroPosition;
//	ptZeroPosition.x = 0;
//	ptZeroPosition.y = 0;
	
	float fMatchRate = 0;
	
	CString szMsg;
	CString szPrevMsg;

	//090324
	pCurStep->m_bRunVideoTest = TRUE;
	if(g_GrabImage.m_bImageLoaded && g_RefImage.m_bImageLoaded)
	{
		nResult = g_ImageProc.PatternMatching(SIZE_TEST,g_GrabImage,g_RefImage,ptResultPosition,fMatchRate,ctrlImgProg);

		pCurStep->m_nTestType = SIZE_TEST;
	
		if(nResult == TEST_ABORT) return 0.0;	

		szMsg.Format("Match : %.1f%% (%d,%d)",fMatchRate,ptResultPosition.x,ptResultPosition.y);
	
		if(CurrentSet->nDisplayType == DETAILEDGRID)
		{
			g_pView->GetResultFromDetailedGrid(pCurStep->m_nStep, szPrevMsg); 
			
			if(szPrevMsg != _T(""))
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szPrevMsg + " , " +szMsg);
				pCurStep->m_strMsg = szPrevMsg + " , " + szMsg;
			}
			else
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szMsg);
				pCurStep->m_strMsg = szMsg;
			}		
		}
	}

	//+del kwmoon 080618
//	g_ImageProc.SetRoi(ptZeroPosition,ptZeroPosition); 

	if(nResult == TEST_PASS) return 1.0;
	else return 0.0;
}

#include <winsock.h>
#include <windowsx.h>
#include "icmpdefs.h"

typedef HANDLE (WINAPI* pfnHV)(VOID);
typedef BOOL   (WINAPI* pfnBH)(HANDLE);
typedef DWORD  (WINAPI* pfnDHDPWPipPDD)(HANDLE, DWORD, LPVOID, WORD,PIP_OPTION_INFORMATION, LPVOID, DWORD, DWORD);

int PingTest()
{
	CString szResultMessage;

	DWORD dwStatus = 0;
	PIP_ECHO_REPLY pIpe = NULL;
    
	char acPingBuffer[64];
    memset(acPingBuffer, '\xAA', sizeof(acPingBuffer));

	HINSTANCE hIcmp = NULL;

	HANDLE hIP = NULL;

	struct hostent* phe;

	int nReturn = 0;

	// Function Pointers
    pfnHV			pIcmpCreateFile  = NULL;
    pfnBH			pIcmpCloseHandle = NULL;
    pfnDHDPWPipPDD	pIcmpSendEcho    = NULL;


    // Load the ICMP.DLL
    hIcmp = LoadLibrary("ICMP.DLL");
   
	if(hIcmp == 0) 
	{
        OkMessage("Unable to locate ICMP.DLL!"); goto END_POSITION;
    }

    // Look up an IP address for the given host name
    if((phe = gethostbyname("12.12.2.2")) == 0) 
	{
        OkMessage("Could not find IP address for 12.12.2.2"); goto END_POSITION;
    }

    // Get handles to the functions inside ICMP.DLL that we'll need
    pIcmpCreateFile  = (pfnHV)GetProcAddress(hIcmp,"IcmpCreateFile");;
    pIcmpCloseHandle = (pfnBH)GetProcAddress(hIcmp,"IcmpCloseHandle");;
    pIcmpSendEcho    = (pfnDHDPWPipPDD)GetProcAddress(hIcmp,"IcmpSendEcho");;

    if((pIcmpCreateFile == 0) || (pIcmpCloseHandle == 0) || (pIcmpSendEcho == 0)) 
	{
        OkMessage("Failed to get proc addr for function"); goto END_POSITION;;
    }

    // Open the ping service
    hIP = pIcmpCreateFile();

    if(hIP == INVALID_HANDLE_VALUE) 
	{
        OkMessage("Unable to open ping service"); goto END_POSITION;
    }
   
    // Build ping packet
    pIpe = (PIP_ECHO_REPLY)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
				           sizeof(IP_ECHO_REPLY) + sizeof(acPingBuffer));
    
	if(pIpe == 0) 
	{
        OkMessage("Failed to allocate global ping packet buffer"); goto END_POSITION;
    }

    pIpe->Data		= acPingBuffer;
    pIpe->DataSize	= sizeof(acPingBuffer);      


    // Send the ping packet
    dwStatus = pIcmpSendEcho(hIP, *((DWORD*)phe->h_addr_list[0]), 
					 acPingBuffer, sizeof(acPingBuffer), NULL, pIpe, 
					 sizeof(IP_ECHO_REPLY) + sizeof(acPingBuffer), 5000);
/*
    if(dwStatus != 0) 
	{
		szResultMessage.Format("Addr: %d.%d.%d.%d RTT: %d ms, TTL : %d",
                int(LOBYTE(LOWORD(pIpe->Address))),
                int(HIBYTE(LOWORD(pIpe->Address))),
                int(LOBYTE(HIWORD(pIpe->Address))),
                int(HIBYTE(HIWORD(pIpe->Address))),
                int(pIpe->RoundTripTime),
                int(pIpe->Options.Ttl));

		OkMessage(szResultMessage);
    }
    else 
	{
		OkMessage("Error obtaining info from ping packet.");
    }
*/

END_POSITION :

    // Shut down
	if(pIpe  != NULL) GlobalFree(pIpe);
    if(hIcmp != NULL) FreeLibrary(hIcmp);

	if(dwStatus != 0) return TEST_PASS;
	else return TEST_FAIL;
}

double	_Lan_Test()
{
	int nResult = TEST_FAIL;

	CString szMsg;

    WSAData wsaData;

	// WSAStartup : Initiates use of WS2_32.DLL
    if(WSAStartup(MAKEWORD(1, 1),&wsaData) != 0) 
	{
        return 0.0; // TEST_FAIL
    }

    nResult = PingTest();

    WSACleanup();
  
	if(nResult == TEST_PASS) return 1.0;
	else return 0.0;
}

//+ 2007.5.8 Add BY USY
double _TVComm_Test()
{
	int nResult = TEST_FAIL;
	CString sMsg = _T("");
	CString sReadStr = _T("");

	//Port Open Check
	if(TVCommCtrl.m_bPortOpen == FALSE)
	{
		if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
		{
			TVCommCtrl.PortClose();
			TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate);
			if(TVCommCtrl.m_bPortOpen == FALSE)
			{
				//+add kwmoon 080313
				CString szErrMsg;
				szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
				AfxMessageBox(szErrMsg);
				return 0.0; 
			}
		}
	}

	if(TVCommCtrl.SendRun(TVCommCtrl.m_strCmd1, TVCommCtrl.m_strCmd2, TVCommCtrl.m_nSetId, TVCommCtrl.m_strData ))
	{
		if(TVCommCtrl.ReceiveCommString(20, TVCommCtrl.m_nWaitLimit, sReadStr))
		{
			sMsg.Format("Receive : %s", sReadStr);
			AddStringToStatus(sMsg);
		}
		else
		{
			sMsg.Format("Read String From TV CommPort Fail!");
			AddStringToStatus(sMsg);
		}

	}
	else
	{
		sMsg.Format("Send Command Fail!");
		AddStringToStatus(sMsg);
	}

	return 1.0;
}

double	_Audio_Test()
{
	int nResult = TEST_FAIL;

	pCurStep->m_nTestType	  = AUDIO_TEST;
	pCurStep->m_bRunAudioTest = TRUE;

	if(g_pView->m_bMakeReferenceMode)
	{
		pCurStep->m_bResult = TRUE; return 1.0;
	}

	//---------------------------------
	// Measure audio with av-switchbox
	//---------------------------------
	if(CurrentSet->nAudioCheckMethod == METHOD_AVSWITCHBOX)
	{
		if(!CurrentSet->bUseAVSwitchBox)
		{
			pCurStep->m_bResult = FALSE; return 1.0;
		}

		//change PSH 081104
//		AvSwitchBoxCtrl.StartAudioMeasureThread(&AvSwitchBoxCtrl);

//		if(AvSwitchBoxCtrl.m_bResult == TRUE)
		if(AvSwitchBoxCtrl.AudioMeasure() == TRUE)
		{
			pCurStep->m_bResult = TRUE;
		}
		else
		{
//			pCurStep->m_bResult = FALSE;
			pCurStep->m_bResult = AvSwitchBoxCtrl.AudioMeasure();
		}
	}
	//-------------------------------
	// Measure audio with sound card
	//-------------------------------
	else
	{
		if(g_SoundCard.AudioMeasure() == TRUE)
		{
			pCurStep->m_bResult = TRUE;
		}
		else
		{
			_Wait(800);

			if(g_SoundCard.AudioMeasure() == TRUE)
			{
				pCurStep->m_bResult = TRUE;
			}
			else
			{
				_Wait(1500);

				pCurStep->m_bResult = g_SoundCard.AudioMeasure();
			}
		}
	}
	return 1.0;
}

//+add kwmoon 071001
double _Manual_Test()
{
	int nResult = TEST_FAIL;
	CString szMsg;

	g_pView->m_ManualTestDlg.DoModal();
	g_pView->m_ManualTestDlg.ClearInfoMessage();
	pCurStep->m_nTestType = MANUAL_TEST;

	if(g_pView->m_ManualTestDlg.m_bTestResult) nResult = TEST_PASS;
	else nResult = TEST_FAIL;


	if(nResult == TEST_PASS) return 1.0;
	else return 0.0;
}

BOOL Grab_LvdsImage_2in1()
{
	CString sGrabPath	= _T("");

	int	nNoRetry		= 0;
	int nGrabResult = GRAB_FAIL;

	if(CurrentSet->bRunAbort)
	{
		g_pView->m_nNoCurrentRepeatExecution = 1; return FALSE;
	}

	int nWidth		= 0;
	int nHeight		= 0;
	int nImageSize	= 0;
//	int nErrorCode	= 0;
//	int nImageBufferSize = 0;
	int nBitCount	= 0;
	int nRowWidth	= 0;

	CString szFileName = _T("");
	CString szErrorMsg = _T("");

	BYTE* pImageBuffer = NULL;

	nGrabResult = GRAB_FAIL;

	CRect nImageRect;
	CWnd* pImageWnd;
	pImageWnd = g_pView->GetDlgItem(IDC_VIDEOVIEW);
	pImageWnd->GetWindowRect(&nImageRect);

	nWidth		= CurrentSet->nLvdsWidth;
	nHeight		= CurrentSet->nLvdsHeight;
	nBitCount	= CurrentSet->nBitCount;
	nRowWidth	= WIDTHBYTES(nBitCount*nWidth);
	nImageSize  = nRowWidth * nHeight;

	g_GrabImage.InitHeaders(COLOR_24BIT,nWidth,nHeight,nImageSize);

	if((nGrabResult = g_pView->Grab_2in1(GRAB_WITH_RETRY)) != GRAB_PASS)
	{
		if(CurrentSet->nDisplayType == DETAILEDGRID)
		{
			szErrorMsg = "No LVDS input image!";
			g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szErrorMsg);
		}

		g_GrabImage.m_bImageLoaded = TRUE;
	}

	ctrlImgProg.SetPos(40);

	g_GrabImage.m_bImageLoaded = TRUE;

	g_pView->InvalidateRect(nImageRect, FALSE);

	g_pView->UpdateWindow(); _Wait(10);	
	
	ctrlImgProg.SetPos(100);

	return TRUE;
}

#define NO_GRAB_FOR_MOVING_PIC_TEST		15

double _Moving_Pic_Test()
{
	int nResult		   = TEST_FAIL;
	int nNoGrab		   = NO_GRAB_FOR_MOVING_PIC_TEST;
	int nNoBlackScreen = 0;

	//+add 090218(Modification No1)
	int nNoMpicColor = 0;
	int nMpicColorThreshold = CurrentSet->nNoUsedColors;

	CString szString		 = _T("");
	CString szMovingPicImage = _T("");
	CString sGrabPath		 = _T("");
	CString sGrabFileName	 = "MovingPic.bmp";

	sGrabPath.Format("%s\\S%d_%s",CurrentSet->sGrabFolder, pCurStep->m_nStep, sGrabFileName);
	
	pCurStep->m_strGrabPath  = sGrabPath;
	pCurStep->m_strProcPath  = sGrabPath.Left(sGrabPath.ReverseFind('.')) + ".rst";
	g_GrabImage.m_szFilePath = sGrabPath;

	//090324
	pCurStep->m_bRunVideoTest = TRUE;

	for(int i=0; i<nNoGrab; i++)
	{
		Grab_LvdsImage_2in1();

		if(g_GrabImage.m_bImageLoaded)
		{
			//+change 090218(Modification No1)
		//	nResult = g_ImageProc.NoVideoSignalTest(g_GrabImage, ctrlImgProg);
			nResult = g_ImageProc.NoVideoSignalTest2(g_GrabImage, nMpicColorThreshold, &nNoMpicColor);	
	
			if(CurrentSet->bSaveMovingPicTestImg)
			{
				if(g_GrabImage.m_szFilePath != _T(""))
				{
					szString =  g_GrabImage.m_szFilePath.Left(g_GrabImage.m_szFilePath.ReverseFind('.'));
					szMovingPicImage.Format("%s_MP%d.bmp",szString,i);

					g_GrabImage.SaveImage(szMovingPicImage,SNAP_IMAGE,ctrlImgProg);
				}
			}

			if(nResult == TEST_ABORT) return 0.0;
			
			if(nResult == TEST_PASS)
			{
				nNoBlackScreen++;
			}

			//+change 
			if(nNoBlackScreen == 1) return 1.0;
		}
		_Wait(100);
	}

	CString szMsg1    = _T("");
	CString szPrevMsg = _T("");

//	int nImageWidth  = g_GrabImage.m_InfoHeader.biWidth;
//	int nImageHeight = g_GrabImage.m_InfoHeader.biHeight;
//	int nNoPixel	 = nImageWidth * nImageHeight - (g_ImageProc.m_nOsdWidth * g_ImageProc.m_nOsdHeight);

	//+add 090218(Modification No1)
	szMsg1.Format("No of color used : %d (Threshold : %d)",nNoMpicColor, nMpicColorThreshold);

	if(CurrentSet->nDisplayType == DETAILEDGRID)
	{
		g_pView->GetResultFromDetailedGrid(pCurStep->m_nStep, szPrevMsg); 
		
		if(szPrevMsg != _T(""))
		{
			g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szPrevMsg + " , " + szMsg1);
			pCurStep->m_strMsg = szPrevMsg + " , " + szMsg1;
		}
		else
		{
			g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szMsg1);
			pCurStep->m_strMsg = szMsg1;
		}		
	}

	if(g_GrabImage.m_szFilePath != _T(""))
	{
		g_GrabImage.SaveImage(sGrabPath,SNAP_IMAGE,ctrlImgProg);
	}

	return 0.0;
}


//+add kwmoon 071108
#define NO_GRAB_FOR_CAPTION_TEST		15

double _Caption_Test()
{
	int nResult			= TEST_FAIL;
	int nNoGrab			= NO_GRAB_FOR_CAPTION_TEST;
	int nNoBlackScreen	= 0;

	int nCaptionKeyDelay		= 0;
	int nCaptionEnterKeyDelay	= 0;
	int nCaptionCheckTime		= 0;
	int nNoOnKeyPress			= 0;
	int nNoOffKeyPress			= 0;

	CString szString			= _T("");
	CString szCaptionImage		= _T("");
	CString szCaptionProcImage	= _T("");

	int nNoLevel	= 255;
	int nLowerLimit = g_ImageProc.Percentage2Level((float)pCurStep->m_fLowLimit,nNoLevel);
	int nUpperLimit = g_ImageProc.Percentage2Level((float)pCurStep->m_fHighLimit,nNoLevel);

	//+del kwmoon 080129
//	if(g_GrabImage.m_bImageLoaded == FALSE) 
//	{
//		AfxMessageBox("Grab Image is not loaded!"); return 100;
//	}
	//090324
	pCurStep->m_bRunVideoTest = TRUE;
	
	if(g_RefImage.m_bImageLoaded == FALSE) 
	{
		AfxMessageBox("Reference Image is not loaded!"); return 100;
	}

	if(g_MaskImage.m_bImageLoaded == FALSE) 
	{
		AfxMessageBox("Mask Image is not loaded!"); return 100;
	}
	
	//+add kwmoon 071224
	nCaptionKeyDelay	  = g_ImageProc.m_nCaptionKeyDelay;
	nCaptionEnterKeyDelay = g_ImageProc.m_nCaptionEnterKeyDelay;
	nCaptionCheckTime	  = g_ImageProc.m_nCaptionCheckTime;	

	//+change kwmoon 080124
	//+add kwmoon 080110
	nNoOnKeyPress			  = g_ImageProc.m_nNoOnKeyPress;
	nNoOffKeyPress			  = g_ImageProc.m_nNoOffKeyPress;
		
	if(pCurStep->m_bStepInternalRetryFlag == FALSE)
	{
		//+change kwmoon 080124
		//+change kwmoon 080110
		// Set Caption Mode On
	//	for(int i=0; i<2; i++)
		for(int i=0; i<nNoOnKeyPress; i++)
		{
			//+2007.12.26 Mod BY USY
			if(!AvSwitchBoxCtrl.SendRemoteCmd(MAX_REMOTE_WAIT_DELAY, "39"))
			{
				return FALSE;
			}
//			AvSwitchBoxCtrl.SendRun2(SEND_REMOTE_CODE,hexCstr2decNum("39"));
			//-

			if(!_Wait(nCaptionKeyDelay)) return 100;
		}

		//+2007.12.26 Mod BY USY
		if(!AvSwitchBoxCtrl.SendRemoteCmd(MAX_REMOTE_WAIT_DELAY, "44"))
		{
			return FALSE;
		}
//		AvSwitchBoxCtrl.SendRun2(SEND_REMOTE_CODE,hexCstr2decNum("44"));
		//-
		if(!_Wait(nCaptionEnterKeyDelay)) return 100;
	}

	//+add kwmoon 071224
	DWORD dwStartTick	= GetTickCount();
	DWORD dwElapsedTime = 0;
	
	//+del kwmoon 071224
//	for(int i=0; i<nNoGrab; i++)
	int nFrameNo = 0;

	while(TRUE)
	{
		Grab_LvdsImage_2in1();

		if(g_GrabImage.m_bImageLoaded)
		{
			nResult = g_ImageProc.CaptionTest(g_GrabImage,g_RefImage,g_MaskImage,nLowerLimit,nUpperLimit,ctrlImgProg);
			
			//+add kwmoon 080125 : Add If statement
			if(CurrentSet->bSaveCaptionTestImg)
			{
				if(g_GrabImage.m_szFilePath != _T(""))
				{
					szString =  g_GrabImage.m_szFilePath.Left(g_GrabImage.m_szFilePath.ReverseFind('.'));
					szCaptionImage.Format("%s_CAP%d.bmp",szString,nFrameNo);
					szCaptionProcImage.Format("%s_CAP_PROC%d.bmp",szString,nFrameNo);

					g_GrabImage.SaveImage(szCaptionImage,SNAP_IMAGE,ctrlImgProg);
					g_GrabImage.SaveImage(szCaptionProcImage,INTERNAL_PROC_IMAGE,ctrlImgProg);
				}
			}

			//+change kwmoon 071224
		//	if(nResult == TEST_ABORT) return 100;
			if(nResult == TEST_ABORT) break;
			
			if(nResult == TEST_PASS)
			{
				nNoBlackScreen++;
			}

			//+change kwmoon 071224
		//	if(nNoBlackScreen == 2) return 0.0;
			if(nNoBlackScreen == 2) break;
		}
		_Wait(200);
		
		dwElapsedTime = GetTickCount()-dwStartTick;

		if(dwElapsedTime > (DWORD)nCaptionCheckTime)
		{
			break;
		}

		nFrameNo++;
	}

	//+change kwmoon 080110
	//+add kwmoon 071224
	// Set Caption Mode Off
//	for(int i=0; i<2; i++)
	for(int i=0; i<nNoOffKeyPress; i++)
	{
		//+2007.12.26 Mod BY USY
		if(!AvSwitchBoxCtrl.SendRemoteCmd(MAX_REMOTE_WAIT_DELAY, "39"))
		{
			return FALSE;
		}
//		AvSwitchBoxCtrl.SendRun2(SEND_REMOTE_CODE,hexCstr2decNum("39"));
		//-

		if(!_Wait(nCaptionKeyDelay)) return 100;
	}

	//+2007.12.26 Mod BY USY
	if(!AvSwitchBoxCtrl.SendRemoteCmd(MAX_REMOTE_WAIT_DELAY, "44"))
	{
		return FALSE;
	}
//	AvSwitchBoxCtrl.SendRun2(SEND_REMOTE_CODE,hexCstr2decNum("44"));
	//-
	if(!_Wait(nCaptionEnterKeyDelay)) return 100;

	//+change kwmoon 071224
//	return 100;
	if(nNoBlackScreen == 2)
	{
		return 0.0;
	}
	else
	{
		return 100;
	}
}

//+add kwmoon 071108
#define NO_GRAB_FOR_DIGITAL_EYE_TEST		15

double _Digital_Eye_Test()
{
	BOOL bReturn = FALSE;

	CString szString = _T("");
	CString szDigitalEyeZeroImage = _T("");
	CString szDigitalEyeZeroProcImage = _T("");
	CString szDigitalEyeNormalImage = _T("");
	CString szDigitalEyeNormalProcImage = _T("");

	int nNoLevel		= 255;
	int nLowerLimit		= g_ImageProc.Percentage2Level((float)pCurStep->m_fLowLimit,nNoLevel);
	int nUpperLimit		= g_ImageProc.Percentage2Level((float)pCurStep->m_fHighLimit,nNoLevel);

	double dDifference	= 0.0f;

	POINT ptRoi1Position;
	ptRoi1Position.x =  g_ImageProc.m_ptRoiPosition.x;
	ptRoi1Position.y =  g_ImageProc.m_ptRoiPosition.y;

	POINT ptRoi2Position;
	ptRoi2Position.x =  g_ImageProc.m_ptRoiPosition.x +  g_ImageProc.m_nRoiWidth;
	ptRoi2Position.y =  g_ImageProc.m_ptRoiPosition.y +  g_ImageProc.m_nRoiHeight;

	
	//090324
	pCurStep->m_bRunVideoTest = TRUE;
	//==============
	// Set DIO Port
	//==============
	if(CurrentSet->bUseAVSwitchBox == TRUE)
	{
		bReturn = AvSwitchBoxCtrl.SetAvSwitch(SET_DIGIT_OUT, MAX_AVSWITCH_WAIT_DELAY, 8, 0);

		//+change kwmoon 080724
	//	if(!bReturn) return 0.0;
		if(!bReturn) return 100; // Fail
	}

	//==================================
	// 1st Osd Test for DigitalEye Zero
	//==================================
	g_ImageProc.SetRoi(ptRoi1Position,ptRoi2Position);

	pCurStep->SetTestParm(NORMAL_PROCESS);

	dDifference = _Osd_Test();

	_Wait(g_ImageProc.m_nDigitalEyeDelay);

	if((dDifference < nLowerLimit) || (dDifference > nUpperLimit))
	{
		return dDifference; // Fail
	}

	//==================================
	// 2nd Osd Test for DigitalEye On
	//==================================
	Grab_LvdsImage_2in1();

	g_ImageProc.SetRoi(ptRoi1Position,ptRoi2Position);

	pCurStep->SetTestParm(REVERSE_PROCESS);

	dDifference = _Osd_Test();

	if((dDifference < nLowerLimit) || (dDifference > nUpperLimit))	
	{
		return 0.0; // Pass
	}	
	else
	{
		return 100; // Fail
	}
}


//+ 2007.11.28 Add BY USY
double _Adc_Test()
{
	int nResult = TEST_FAIL;
	int nNoTest = TVCommCtrl.m_aCmd1.GetSize();

	CString szErrMsg;  //PSH
	CString szString = _T("");
	g_pView->m_bAdcRunning = TRUE;

	//==============
	// Using RS232C  
	//==============
	if(CurrentSet->nAdcType == ADC_TYPE_RS232C)
	{
		if(!CurrentSet->bUseTVCommPort)
		{
			szErrMsg.LoadString(IDS_COMMERROR);
			szErrMsg = szErrMsg + " (TV COM Port)";
			AfxMessageBox(szErrMsg);
			return 0.0;
		}

		if(TVCommCtrl.m_bPortOpen == FALSE)
		{
			if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
			{
				TVCommCtrl.PortClose();
				if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
				{
					szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
					AfxMessageBox(szErrMsg);
					return 0.0;
				}
			}
		}  

		for(int i=0; i<nNoTest; i++)
		{
			nResult = TVCommCtrl.AdcTest(TVCommCtrl.m_aCmd1.GetAt(i),
										 TVCommCtrl.m_aCmd2.GetAt(i),
										 TVCommCtrl.m_aSetId.GetAt(i),
										 TVCommCtrl.m_aData.GetAt(i),
										 TVCommCtrl.m_aCheckType.GetAt(i),
										 TVCommCtrl.m_aWaitLimit.GetAt(i),
										 TVCommCtrl.m_aCheckOption.GetAt(i));

			if(nResult == TEST_TIMEOUT)
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, "ADC TIMEOUT");
				TVCommCtrl.ResetArray();
				g_pView->m_bAdcRunning = FALSE;
				
				return 0.0;
			}
			else if(nResult == TEST_FAIL)
			{
			//	InsertMsg2DetailedGrid(pCurStep->m_nStep, "ADC FAIL");
				TVCommCtrl.ResetArray();
				g_pView->m_bAdcRunning = FALSE;
				
				return 0.0;
			}
			_Wait(200);
		}

		TVCommCtrl.ResetArray();
		g_pView->m_bAdcRunning = FALSE;
	//	InsertMsg2DetailedGrid(pCurStep->m_nStep, "ADC_PASS");
		
		return 1.0;
	}
	//===========
	// Using I2C 
	//===========
	else
	{
		if(!pCurStep->m_bAdcTestResult)
		{
			g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, "ADC FAIL");
			g_pView->m_bAdcRunning = FALSE;
			
			return 0.0;
		}
		//_Wait(200);	

		g_pView->m_bAdcRunning = FALSE;
		g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, "ADC_PASS");
		
		return 1.0;	
	}
}

//+add PSH 080417
/*
double _ADC_AdjConfirmation()
{
	if(TVCommCtrl.ADC_AdjConfirmation())
	{
		return 1.0;	
	}
	else{
		return 0.0;	
	}
}
*/
//+change PSH 091124
double _ADC_AdjResultCheck()
{

	if(TVCommCtrl.ADC_Adj_ResultCheck(5000))
	{
		return 1.0;	
	}
	else{
		return 0.0;	
	}
}
/*
double _EDID_DownloadResultCheck()
{
	int nAdjItem;

	TVCommCtrl.EDID_Download_ResultCheck(nAdjItem);

	return (double)nAdjItem;	

}
*/
//+add kwmoon 080722
double _Color_Bias_Test()
{
	int nResult = TEST_FAIL;

	CString szString  = _T("");
	CString szPrevMsg = _T("");
	CString szMsg1	  = _T("");
	
	CString sMsg	  = _T("");
	DWORD dwFuncTickCount     = 0;
	DWORD dwFuncElapsedTime   = 0;
	CString szFuncElapsedTime = _T("");

	int   nColorDepth  = 0;
	int   nNoLevel	   = 0;
	int	  nMargin	   = 0;
	int	  nDifference  = 0;
	float fReturnPercentageValue = 0;

	if(CurrentSet->bSaveProcessingTimeData)
	{
		sMsg.Format("  B-ColorBiasTest");
		AddTimeData(sMsg);
		dwFuncTickCount = GetTickCount();
	}
	//090324
	pCurStep->m_bRunVideoTest = TRUE;

	g_ImageProc.SetColorLimit((float)pCurStep->m_fLowLimit,(float)pCurStep->m_fHighLimit);

	if(g_GrabImage.m_bImageLoaded)
	{
		nResult = g_ImageProc.ColorBiasTest(g_GrabImage,nDifference,szMsg1,ctrlImgProg);
		
		pCurStep->m_nTestType = BIAS_TEST;
	
		nColorDepth	 = g_GrabImage.m_InfoHeader.biBitCount;

		//+change kwmoon 080722
	//	nNoLevel	 = (int)pnow(2,(nColorDepth/3));
	//	nNoLevel	 = (int)pow(2,(nColorDepth/3))-1;

		//+change kwmoon 080411
		if(CurrentSet->bSaveGrabImg
		||(!CurrentSet->bSaveGrabImg && (nResult == TEST_FAIL)))
		{
			if(pCurStep->m_strGrabPath == _T(""))
			{
				pCurStep->m_strGrabPath = g_GrabImage.m_szFilePath;
			}
			g_GrabImage.SaveImage(pCurStep->m_strGrabPath, SNAP_IMAGE,ctrlImgProg);
		}
		
		if(CurrentSet->nDisplayType == DETAILEDGRID)
		{
			g_pView->GetResultFromDetailedGrid(pCurStep->m_nStep, szPrevMsg); 
			
			if(szPrevMsg != _T(""))
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szPrevMsg + " , " + szMsg1);
				pCurStep->m_strMsg = szPrevMsg + " , " + szMsg1;
			}
			else
			{
				g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szMsg1);
				pCurStep->m_strMsg = szMsg1;
			}		
		}

		fReturnPercentageValue = (float)nDifference;//g_ImageProc.Level2Percentage(nDifference,nNoLevel);

		if(nResult == TEST_ABORT) return 255;//MAX_COLOR_LEVEL;
	}
	else
	{
		AfxMessageBox("Failed to load grab image"); return 255; 
	}

	return fReturnPercentageValue; 	
}

double	_Version_Check()
{
	CString sCpuVersion   = _T("");
	CString sMicomVersion = _T("");
	CString sUsbVersion	  = _T("");
	CString sFrcVersion   = _T("");
	BOOL bResult1 = TRUE;
	BOOL bResult2 = TRUE;
	BOOL bResult3 = TRUE;
	int  nI2cResult;
	int i;
	int nData[3]   = {0,0,0};

	if(CurrentSet->nTVControlType)
	{
		for(i= 0; i<5; i++)
		{
			nI2cResult = I2cAdcCtrl.ReadVersion();
			if(nI2cResult == TEST_PASS) break;
		}

		if(nI2cResult != TEST_PASS)
		{
			return FALSE;
		}
		else
		{
			// change psh 100310
			nData[0] = hexCstr2decNum(I2cAdcCtrl.m_szI2cAdcReadString.Mid(CMD_LENGTH,2));
			nData[1] = hexCstr2decNum(I2cAdcCtrl.m_szI2cAdcReadString.Mid(CMD_LENGTH + 2,2));
			nData[2] = hexCstr2decNum(I2cAdcCtrl.m_szI2cAdcReadString.Mid(CMD_LENGTH + 4,2));
			if(nData[2] > 99)
			{					
				sCpuVersion.Format("%02d.%02d.%02X", nData[0], nData[1], nData[2]);
			}
			else{
				sCpuVersion.Format("%02d.%02d.%02d", nData[0], nData[1], nData[2]);
			}
		//	sCpuVersion = I2cAdcCtrl.m_szI2cAdcReadString.Mid(CMD_LENGTH,6);
		//	sCpuVersion.Insert(2, '.');
		//	sCpuVersion.Insert(5, '.');

			nData[0] = hexCstr2decNum(I2cAdcCtrl.m_szI2cAdcReadString.Mid(CMD_LENGTH + 6,2));
			nData[1] = hexCstr2decNum(I2cAdcCtrl.m_szI2cAdcReadString.Mid(CMD_LENGTH + 8,2));
			nData[2] = hexCstr2decNum(I2cAdcCtrl.m_szI2cAdcReadString.Mid(CMD_LENGTH + 10,2));
			if(nData[2] > 99)
			{					
				sMicomVersion.Format("%02d.%02d.%02X", nData[0], nData[1], nData[2]);
			}
			else{
				sMicomVersion.Format("%02d.%02d.%02d", nData[0], nData[1], nData[2]);
			}

		//	sMicomVersion = I2cAdcCtrl.m_szI2cAdcReadString.Mid(CMD_LENGTH + 6,6);
		//	sMicomVersion.Insert(2, '.');
		//	sMicomVersion.Insert(5, '.');

			nData[0] = hexCstr2decNum(I2cAdcCtrl.m_szI2cAdcReadString.Mid(CMD_LENGTH + 12,2));
			nData[1] = hexCstr2decNum(I2cAdcCtrl.m_szI2cAdcReadString.Mid(CMD_LENGTH + 14,2));
			nData[2] = hexCstr2decNum(I2cAdcCtrl.m_szI2cAdcReadString.Mid(CMD_LENGTH + 16,2));
			if(nData[2] > 99)
			{					
				sUsbVersion.Format("%02d.%02d.%02X", nData[0], nData[1], nData[2]);
			}
			else{
				sUsbVersion.Format("%02d.%02d.%02d", nData[0], nData[1], nData[2]);
			}
		//	sUsbVersion = I2cAdcCtrl.m_szI2cAdcReadString.Mid(CMD_LENGTH + 12,6);
		//	sUsbVersion.Insert(2, '.');
		//	sUsbVersion.Insert(5, '.');

//			sFrcVersion = I2cAdcCtrl.m_szI2cAdcReadString.Mid(CMD_LENGTH + 18,6);
//			sFrcVersion.Insert(2, '.');
//			sFrcVersion.Insert(5, '.');
		}
		sCpuVersion.MakeUpper(); 
		if(sCpuVersion.Compare(CurrentSet->sCPUVersion) != 0){
			bResult1 = FALSE;
		}

		if(CurrentSet->sMicomVersion != "")
		{ 
			sMicomVersion.MakeUpper(); 
			if(sMicomVersion.Compare(CurrentSet->sMicomVersion) != 0){
				bResult2 = FALSE;
			}
		}
		if(CurrentSet->sUSBVersion != "")
		{ 
			sUsbVersion.MakeUpper(); 
			if(sUsbVersion.Compare(CurrentSet->sUSBVersion) != 0){
				bResult3 = FALSE;
			}
		}

	}
	else{
		bResult1 = TVCommCtrl.Firmware_VersionCheck(CPU_VER, CurrentSet->sCPUVersion);

		if(CurrentSet->sMicomVersion != "")
		{ 
			bResult2 = TVCommCtrl.Firmware_VersionCheck(MICOM_VER, CurrentSet->sMicomVersion);
		}

		if(CurrentSet->sUSBVersion != "")
		{ 
			bResult3 = TVCommCtrl.Firmware_VersionCheck(USB_VER, CurrentSet->sUSBVersion);
		}
	}
	
	if(bResult1 && bResult2 && bResult3)
	{
		return 1.0;	
	}
	else
	{
		return 0.0;	
	}
}
double	_Option_Check()
{
	BOOL bResult1 = TRUE;
	BOOL bResult2 = TRUE;
	BOOL bResult3 = TRUE;
	BOOL bResult4 = TRUE;
	BOOL bResult5 = TRUE;
	BOOL bResult6 = TRUE;

	int nToolOption;

	if(CurrentSet->sToolOption1 != ""){
		nToolOption = atoi(CurrentSet->sToolOption1);
		if(CurrentSet->nTVControlType){
		//	_Wait(500);
			bResult1 = I2cAdcCtrl.Check_Option(TOOL_OPTION1, nToolOption);
		}
		else{
			bResult1 = TVCommCtrl.Check_Option(TOOL_OPTION1, nToolOption);
		}
	}

	if(CurrentSet->sToolOption2 != ""){
		nToolOption = atoi(CurrentSet->sToolOption2);
		if(CurrentSet->nTVControlType){
			_Wait(300);
			bResult2 = I2cAdcCtrl.Check_Option(TOOL_OPTION2, nToolOption);
		}
		else{
			bResult2 = TVCommCtrl.Check_Option(TOOL_OPTION2, nToolOption);
		}
	}
	
	if(CurrentSet->sToolOption3 != ""){
		nToolOption = atoi(CurrentSet->sToolOption3);
		if(CurrentSet->nTVControlType){
			_Wait(300);
			bResult3 = I2cAdcCtrl.Check_Option(TOOL_OPTION3, nToolOption);
		}
		else{
			bResult3 = TVCommCtrl.Check_Option(TOOL_OPTION3, nToolOption);
		}
	}

	if(CurrentSet->sToolOption4 != ""){
		nToolOption = atoi(CurrentSet->sToolOption4);
		if(CurrentSet->nTVControlType){
			_Wait(300);
			bResult4 = I2cAdcCtrl.Check_Option(TOOL_OPTION4, nToolOption);
		}
		else{
			bResult4 = TVCommCtrl.Check_Option(TOOL_OPTION4, nToolOption);
		}
	}

	if(CurrentSet->sToolOption5 != ""){
		nToolOption = atoi(CurrentSet->sToolOption5);
		if(CurrentSet->nTVControlType){
			_Wait(300);
			bResult5 = I2cAdcCtrl.Check_Option(TOOL_OPTION5, nToolOption);
		}
		else{
			bResult5 = TVCommCtrl.Check_Option(TOOL_OPTION5, nToolOption);
		}
	}
	if(CurrentSet->sToolOption6 != ""){
		nToolOption = atoi(CurrentSet->sToolOption6);
		if(CurrentSet->nTVControlType){
			_Wait(300);
			bResult5 = I2cAdcCtrl.Check_Option(TOOL_OPTION6, nToolOption);
		}
		else{
			bResult5 = TVCommCtrl.Check_Option(TOOL_OPTION6, nToolOption);
		}
	}

	if(CurrentSet->sAreaOption1 != ""){
		nToolOption = atoi(CurrentSet->sAreaOption1);
		if(CurrentSet->nTVControlType){
			_Wait(300);
			bResult6 = I2cAdcCtrl.Check_Option(AREA_OPTION1, nToolOption);
		}
		else{
			bResult6 = TVCommCtrl.Check_Option(AREA_OPTION1, nToolOption);
		}
	}

	if(bResult1 && bResult2 && bResult3  && bResult4  && bResult5  && bResult6)
	{
		return 1.0;	

	}
	else{
		return 0.0;	
	}

}

double	_Option_CheckAll()
{
	BOOL bResult1 = TRUE;
	BOOL bResult2 = TRUE;

	int nToolOption1 = 0;
	int nToolOption2 = 0;
	int nToolOption3 = 0;
	int nToolOption4 = 0;
	int nToolOption5 = 0;
	int nToolOption6 = 0;
	int nAreaOption;

	if(CurrentSet->sToolOption1 != ""){
		nToolOption1 = atoi(CurrentSet->sToolOption1);
	}

	if(CurrentSet->sToolOption2 != ""){
		nToolOption2 = atoi(CurrentSet->sToolOption2);
	}
	
	if(CurrentSet->sToolOption3 != ""){
		nToolOption3 = atoi(CurrentSet->sToolOption3);
	}

	if(CurrentSet->sToolOption4 != ""){
		nToolOption4 = atoi(CurrentSet->sToolOption3);
	}

	if(CurrentSet->sToolOption5 != ""){
		nToolOption5 = atoi(CurrentSet->sToolOption5);
	}

	if(CurrentSet->sToolOption6 != ""){
		nToolOption6 = atoi(CurrentSet->sToolOption6);
	}

	if(CurrentSet->nTVControlType){
		bResult1 = I2cAdcCtrl.Check_OptionAll(nToolOption1, nToolOption2, nToolOption3, nToolOption4, nToolOption5, nToolOption6);
	}
	else{
		bResult1 = TVCommCtrl.Check_OptionAll(nToolOption1, nToolOption2, nToolOption3, nToolOption4, nToolOption5, nToolOption6);
	}


	if(CurrentSet->sAreaOption1 != ""){
		nAreaOption = atoi(CurrentSet->sAreaOption1);
		if(CurrentSet->nTVControlType){
			bResult2 = I2cAdcCtrl.Check_Option(AREA_OPTION1, nAreaOption);
		}
		else{
			bResult2 = TVCommCtrl.Check_Option(AREA_OPTION1, nAreaOption);
		}
	}

	if(bResult1 && bResult2)
	{
		return 1.0;	

	}
	else{
		return 0.0;	
	}

}

//+add 080216(Modification No1)
double _Module_Voltage_Test()
{
	float fMeasuredValue = 0.0;
	int nIndex;
	CString sTemp;
	BOOL bResult = FALSE;

	for(nIndex = 0; nIndex < 50; nIndex++)
	{
		
		bResult = I2cAdcCtrl.GetModuleVoltage(fMeasuredValue);

		if (pCurStep->GetHighLimit() < fMeasuredValue || pCurStep->GetLowLimit() > fMeasuredValue) 
		{
			_Wait(500);
		}
		else{
			break;
		}
		//090511
		if(CurrentSet->bRunAbort)
		{
			break;
		}
	}

	pCurStep->m_nTestType = MODULE_TEST;

	if (pCurStep->GetHighLimit() < fMeasuredValue || pCurStep->GetLowLimit() > fMeasuredValue)
	{
		if(bResult){
			sTemp.Format("T:%f,  M:%f", pCurStep->GetNominal_float(), fMeasuredValue);
		}
		else{
			sTemp.Format("T:%f,  M: Error-I2C Response Data", pCurStep->GetNominal_float());
		}
		pCurStep->m_strMsg = sTemp;
	}
	return fMeasuredValue; 	
}

//+add 090304(Modification No1)
double _EDID_Download()
{
	CString szErrMsg;  //PSH

	//Change 090715
	if(!HDMIGeneratorCtrl.SetDDCLine_OpenClose(TRUE)){
		InitHDMIGen(CurrentSet->sHDMIComPort, CurrentSet->wHDMIBaudRate);
		if(!HDMIGeneratorCtrl.SetDDCLine_OpenClose(TRUE)){
			return 0.0;
		}
	}
	_Wait(500);
	if(CurrentSet->nTVControlType){
		if(I2cAdcCtrl.EDID_Download() != TEST_PASS)
		{
			return 0.0;
		}
	}
	else{
		if(TVCommCtrl.m_bPortOpen == FALSE)
		{
			if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
			{
				TVCommCtrl.PortClose();
				if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
				{
					szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
					AfxMessageBox(szErrMsg);
					return 0.0;
				}
			}
		} 
		
		if(!TVCommCtrl.EDID_Download(8000)){
			return 0.0;
		}
	}

	if(!HDMIGeneratorCtrl.SetDDCLine_OpenClose(FALSE)){
		InitHDMIGen(CurrentSet->sHDMIComPort, CurrentSet->wHDMIBaudRate);
		if(!HDMIGeneratorCtrl.SetDDCLine_OpenClose(FALSE)){
			return 0.0;
		}
	}
	_Wait(500);

	if(!HDMIGeneratorCtrl.SetEDID_PassCheck(FALSE)){
		InitHDMIGen(CurrentSet->sHDMIComPort, CurrentSet->wHDMIBaudRate);
		if(!HDMIGeneratorCtrl.SetEDID_PassCheck(FALSE)){
			return 0.0;
		}
	}

	_Wait(500);
	if(!HDMIGeneratorCtrl.SetHDCP_OnOff(FALSE)){
		InitHDMIGen(CurrentSet->sHDMIComPort, CurrentSet->wHDMIBaudRate);
		if(!HDMIGeneratorCtrl.SetHDCP_OnOff(FALSE)){
			return 0.0;
		}
	}
	
	return 1.0;
}

//+add 090325(Modification No1)
double _LAN_Port_Check()
{
	CString szErrMsg;  //PSH

	if(TVCommCtrl.m_bPortOpen == FALSE)
	{
		if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
		{
			TVCommCtrl.PortClose();
			if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
			{
				szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
				AfxMessageBox(szErrMsg);
				return 0.0;
			}
		}
	}  
	if(!TVCommCtrl.LAN_Port_Check(8000)){
		return 0.0;
	}
	
	return 1.0;
}
double _ESN_Download_Check()
{
	CString szErrMsg;  //PSH

	if(TVCommCtrl.m_bPortOpen == FALSE)
	{
		if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
		{
			TVCommCtrl.PortClose();
			if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
			{
				szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
				AfxMessageBox(szErrMsg);
				return 0.0;
			}
		}
	}  
	if(!TVCommCtrl.ESN_Download_Check(5000)){
		return 0.0;
	}
	
	return 1.0;
}

//add 090527
double _Domming_Check()
{
	CString szString  = _T("");
	CString szPrevMsg = _T("");
	CString szMsg1	  = _T("");
	int nReturn;

	nReturn = g_pView->LocalDimmingTest();
	
	switch(nReturn)
	{
		case 0:
			szMsg1.Format("Dimming Check : OK");
			break;
		case 1:	
			szMsg1.Format("Dimming Check : Address mis-match");
			break;
		case 2:	
			szMsg1.Format("Dimming Check : Command mis-match");
			break;
		case 3:
			szMsg1.Format("Dimming Check : Checksum mis-match");
			break;
		case -1:
			szMsg1.Format("Dimming Check : Error");
			break;
	}

	if(CurrentSet->nDisplayType == DETAILEDGRID)
	{
		g_pView->GetResultFromDetailedGrid(pCurStep->m_nStep, szPrevMsg); 
		
		if(szPrevMsg != _T(""))
		{
			g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szPrevMsg + " , " + szMsg1);
			pCurStep->m_strMsg = szPrevMsg + " , " + szMsg1;
		}
		else
		{
			g_pView->InsertMsg2DetailedGrid(pCurStep->m_nStep, szMsg1);
			pCurStep->m_strMsg = szMsg1;
		}		
	}


	if(nReturn == 0)
	{
		return 1.0;
	}
	else
	{
		return 0.0;
	}
}

//add 091118
double _CI_Key_Check()
{
	CString szErrMsg;  //PSH
	BOOL bResult1;
//	BOOL bResult2;

	if(TVCommCtrl.m_bPortOpen == FALSE)
	{
		if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
		{
			TVCommCtrl.PortClose();
			if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
			{
				szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
				AfxMessageBox(szErrMsg);
				return 0.0;
			}
		}
	}  
	bResult1 = TVCommCtrl.CI_Download_Check1(3000);
// del 20101108
//	bResult2 = TVCommCtrl.CI_Download_Check2(3000);

//	if(bResult1 && bResult2){
	if(bResult1){
		return 1.0;
	}
	else{
		return 0.0;
	}
}
//add 101011
double _CI_Card_Check()
{
	CString szErrMsg;  //PSH
	BOOL bResult;

	if(TVCommCtrl.m_bPortOpen == FALSE)
	{
		if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
		{
			TVCommCtrl.PortClose();
			if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
			{
				szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
				AfxMessageBox(szErrMsg);
				return 0.0;
			}
		}
	}  
	bResult = TVCommCtrl.CI_Card_Check(3000);

	if(bResult){
		return 1.0;
	}
	else{
		return 0.0;
	}
}
double _Marlin_Download_Check()
{
	CString szErrMsg;  //PSH
	BOOL bResult;

	if(TVCommCtrl.m_bPortOpen == FALSE)
	{
		if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
		{
			TVCommCtrl.PortClose();
			if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
			{
				szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
				AfxMessageBox(szErrMsg);
				return 0.0;
			}
		}
	}  
	bResult = TVCommCtrl.Marlin_Download_Check(3000);

	if(bResult){
		return 1.0;
	}
	else{
		return 0.0;
	}
}
double _BuiltIn_Wifi_Check()
{
	CString szErrMsg;  //PSH
	BOOL bResult;

	if(TVCommCtrl.m_bPortOpen == FALSE)
	{
		if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
		{
			TVCommCtrl.PortClose();
			if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
			{
				szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
				AfxMessageBox(szErrMsg);
				return 0.0;
			}
		}
	}  
	bResult = TVCommCtrl.BuiltIn_Wifi_Check(3000);

	if(bResult){
		return 1.0;
	}
	else{
		return 0.0;
	}
}

//+add 091124(Modification No1)
double _RJP_Port_Check()
{
	CString szErrMsg;  //PSH

	if(TVCommCtrl.m_bPortOpen == FALSE)
	{
		if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
		{
			TVCommCtrl.PortClose();
			if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
			{
				szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
				AfxMessageBox(szErrMsg);
				return 0.0;
			}
		}
	}  
	if(!TVCommCtrl.RJP_Port_Check(4000)){
		return 0.0;
	}
	
	return 1.0;
}

//+add 091124(Modification No1)
double _Magic_Remocon_Check()
{
	CString szErrMsg;  //PSH

	if(TVCommCtrl.m_bPortOpen == FALSE)
	{
		if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
		{
			TVCommCtrl.PortClose();
			if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
			{
				szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
				AfxMessageBox(szErrMsg);
				return 0.0;
			}
		}
	}  
	if(!TVCommCtrl.Magic_Remocon_Check(2000)){
		return 0.0;
	}
	
	return 1.0;
}

//+add 091124(Modification No1)
double _Wireless_Ready_Check()
{
	CString szErrMsg;  //PSH

	if(TVCommCtrl.m_bPortOpen == FALSE)
	{
		if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
		{
			TVCommCtrl.PortClose();
			if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
			{
				szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
				AfxMessageBox(szErrMsg);
				return 0.0;
			}
		}
	}  
	if(!TVCommCtrl.Wireless_Ready_Check(8000)){
		return 0.0;
	}
	
	return 1.0;
}

double _DMM_MeasureDC()
{
	double vol;
	CString s;

	vol = DMM.MeasureDC(DMM.m_nMeasureChannel);

	s = pCurStep->GetUnit();
	s.TrimLeft();
	s.TrimRight();
	s.MakeUpper();
	if(s == "MV")
		vol = vol*1000.;

	return vol;
}

double _DMM_MeasureAC()
{
	double vol;
	CString s;

	vol = DMM.MeasureAC(DMM.m_nMeasureChannel);

	s = pCurStep->GetUnit();
	s.TrimLeft();
	s.TrimRight();
	s.MakeUpper();
	if(s == "MV")
		vol = vol*1000.;

	return vol;
}

double _DMM_MeasureResistance()
{
	double res;
	CString s;
//	double bf;
//	double sum;
//	int index;

	res = DMM.MeasureResistance(DMM.m_nMeasureChannel);

/*	Sleep(50);
	res = DMM.MeasureResistance(DMM.m_nMeasureChannel);
	Sleep(50);
	res = DMM.MeasureResistance(DMM.m_nMeasureChannel);
	Sleep(80);
	res = DMM.MeasureResistance(DMM.m_nMeasureChannel);
*/
	s = pCurStep->GetUnit();
	s.TrimLeft();
	s.TrimRight();
	s.MakeUpper();

	if(s == "KOHM")
		res = res/1000.;
	else if(s == "MOHM")
		res = res/1000000.;

	return res;
}

double _DMM_MeasureResistance2()
{
	double res;
	CString s;
//	double bf;
//	double sum;
//	int index;

	res = DMM.MeasureResistance2(DMM.m_nMeasureChannel);

/*	Sleep(50);
	res = DMM.MeasureResistance(DMM.m_nMeasureChannel);
	Sleep(50);
	res = DMM.MeasureResistance(DMM.m_nMeasureChannel);
	Sleep(80);
	res = DMM.MeasureResistance(DMM.m_nMeasureChannel);
*/
	s = pCurStep->GetUnit();
	s.TrimLeft();
	s.TrimRight();
	s.MakeUpper();

	if(s == "KOHM")
		res = res/1000.;
	else if(s == "MOHM")
		res = res/1000000.;

	return res;
}

double _DMM_MeasureResistance3()
{
	double res;
	CString s;

	res = DMM.MeasureResistance3(DMM.m_nMeasureChannel);

	s = pCurStep->GetUnit();
	s.TrimLeft();
	s.TrimRight();
	s.MakeUpper();

	if(s == "KOHM")
		res = res/1000.;
	else if(s == "MOHM")
		res = res/1000000.;

	return res;
}

double _DMM_MeasureFrequency()
{
	double res;
	CString s;

	res = DMM.MeasureFrequency(DMM.m_nMeasureChannel);

	s = pCurStep->GetUnit();
	s.TrimLeft();
	s.TrimRight();
	s.MakeUpper();

	if(s == "KHZ")
		res = res/1000.;
	else if(s == "MHZ")
		res = res/1000000.;

	return res;
}

double _DMM_MeasurePeriod()
{
	double res;
	CString s;

	res = DMM.MeasurePeriod(DMM.m_nMeasureChannel);

	s = pCurStep->GetUnit();
	s.TrimLeft();
	s.TrimRight();
	s.MakeUpper();

	if(s == "MSEC")
		res = res*1000.;
	else if(s == "USEC")
		res = res*1000000.;

	return res;
}

double _DMM_GetMonitoringData()
{
	double dVal;
	CString s;

	dVal = DMM.Monitoring_DataRead();

	s = pCurStep->GetUnit();
	s.TrimLeft();
	s.TrimRight();
	s.MakeUpper();

	if(DMM.m_nMonitorFunction == 3)
	{
		if(s == "KOHM")
			dVal = dVal/1000.;
		else if(s == "MOHM")
			dVal = dVal/1000000.;
	}
	else
	{
		if(s == "MV")
			dVal = dVal*1000.;
	}

	return dVal;
}
//add 101108
double _Widevine_Download_Check()
{
	CString szErrMsg;  //PSH
	BOOL bResult;

	if(TVCommCtrl.m_bPortOpen == FALSE)
	{
		if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
		{
			TVCommCtrl.PortClose();
			if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
			{
				szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
				AfxMessageBox(szErrMsg);
				return 0.0;
			}
		}
	}  
	bResult = TVCommCtrl.Widevine_Download_Check(3000);

	if(bResult){
		return 1.0;
	}
	else{
		return 0.0;
	}
}

//add 101115
double _RF_Emitter_Check()
{
	CString szErrMsg;  //PSH

	if(TVCommCtrl.m_bPortOpen == FALSE)
	{
		if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
		{
			TVCommCtrl.PortClose();
			if(TVCommCtrl.Create(CurrentSet->sTVComPort, CurrentSet->wTVBaudRate) == FALSE)
			{
				szErrMsg.Format("Failed to open COM port (%s)",CurrentSet->sTVComPort);
				AfxMessageBox(szErrMsg);
				return 0.0;
			}
		}
	}  
	if(!TVCommCtrl.RF_Emitter_Check(2000)){
		return 0.0;
	}
	
	return 1.0;
}
